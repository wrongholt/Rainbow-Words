'use strict';

const expect = require('chai').expect;
const sinon = require('sinon');
const proxyquire = require('proxyquire');

const httpClient = require('@root/lib/clients/http-client');
const urlUtility = require('@root/lib/utils/url-utils');
const logger = require('@root/lib/utils/logger-utility');


describe('Clients test - cli http request client', () => {
    const VALID_OPTIONS = { url: 'https://test.com' };
    const BLANK_URL_OPTIONS = { url: '     ' };
    const INVALID_URL_OPTIONS = { url: 'https//test.com' };
    const INVALID_OPERATION = {};
    const VALID_OPERATION = 'valid-operation';
    
    describe('# input parameter validation', () => {
        it('| input operation is not a string, expect fatal error', (done) => {
            // call
            httpClient.request(VALID_OPTIONS, INVALID_OPERATION, false, (err) => {
                // verify
                expect(err).equal('[Fatal]: CLI request must have a non-empty operation name.');
                done();
            });
        });

        it('| input operation url is a blank string, expect fatal error', (done) => {
            // call 
            httpClient.request(BLANK_URL_OPTIONS, VALID_OPERATION, false, (err) => {
                // verify
                expect(err).equal('[Fatal]: CLI request must call with valid url.');
                done();
            });
        });
        
        it('| input operation url is not a valid url, expect fatal error', (done) => {
            // setup
            sinon.stub(urlUtility, 'isValidUrl');
            urlUtility.isValidUrl.withArgs(INVALID_URL_OPTIONS).returns(false);
            // call
            httpClient.request(INVALID_URL_OPTIONS, VALID_OPERATION, false, (err) => {
                // verify
                expect(err).equal('[Fatal]: CLI request must call with valid url.');
                urlUtility.isValidUrl.restore();
                done();
            });
        });
    });

    describe('# embedding user-agent', () => {
        let stubRequest;
        let proxyhttpClient;
        let initialDownstreamClient;

        before(() => {
            initialDownstreamClient = process.env.ASK_DOWNSTREAM_CLIENT;
            stubRequest = sinon.stub();
            proxyhttpClient = proxyquire('@root/lib/clients/http-client', { 'request': stubRequest });
        });
        
        it('| no downstream client, expect CLI user agent', (done) => {
            // setup
            process.env.ASK_DOWNSTREAM_CLIENT = '';
            stubRequest.callsFake(() => {});
            // call
            proxyhttpClient.request(VALID_OPTIONS, VALID_OPERATION, false, () => {});
            // verify
            expect(stubRequest.args[0][0]).to.have.property('headers');
            expect(stubRequest.args[0][0].headers).to.have.property('User-Agent');
            expect(stubRequest.args[0][0].headers['User-Agent'].startsWith('ask-cli')).equal(true);
            done();
        });

        it('| downstream client environmental variable exists, expect downstream user agent', (done) => {
            // setup
            const TEST_DOWNSTREAM = 'test_downstream';
            process.env.ASK_DOWNSTREAM_CLIENT = TEST_DOWNSTREAM;
            stubRequest.callsFake(() => { });
            // call
            proxyhttpClient.request(VALID_OPTIONS, VALID_OPERATION, false, () => {});
            // verfiy
            expect(stubRequest.args[0][0]).to.have.property('headers');
            expect(stubRequest.args[0][0].headers).to.have.property('User-Agent');
            expect(stubRequest.args[0][0].headers['User-Agent'].startsWith(TEST_DOWNSTREAM)).equal(true);
            done();
        });

        after(() => {
            process.env.ASK_DOWNSTREAM_CLIENT = initialDownstreamClient;
        });
    });

    describe('# call request correctly', () => {
        let stubRequest;
        let proxyhttpClient;

        const expectedError = `[Error]: Failed to make request to ${VALID_OPERATION}. Please make sure "${VALID_OPTIONS.url}" is responding.`;

        before(() => {
            stubRequest = sinon.stub();
            proxyhttpClient = proxyquire('@root/lib/clients/http-client', { 'request': stubRequest });
        });
        
        it('| request error occurs, expect error message', (done) => {
            // setup
            stubRequest.callsArgWith(1, 'error', null);
            // call
            proxyhttpClient.request(VALID_OPTIONS, VALID_OPERATION, false, (err, response) => {
                // verify
                expect(err).equal(expectedError);
                expect(response).equal(undefined);
                done();
            });
        });

        it('| request with no error and no response, expect error', (done) => {
            // setup
            stubRequest.callsArgWith(1, null, null);
            // call
            proxyhttpClient.request(VALID_OPTIONS, VALID_OPERATION, false, (err, response) => {
                // verify
                expect(err).equal(expectedError);
                expect(response).equal(undefined);
                done();
            });
        });

        it('| request with success, expect no error and response', (done) => {
            // setup
            stubRequest.callsArgWith(1, null, 'response');
            // call
            proxyhttpClient.request(VALID_OPTIONS, VALID_OPERATION, false, (err, response) => {
                // verify
                expect(err).equal(null);
                expect(response).equal('response');
                done();
            });
        });

        it('| request with no error and debug flag, expect logger filled with correct debug info', (done) => {
            // setup
            const fakeResponse = {
                request: {
                    method: 'method',
                    href: 'href',
                    headers: 'request headers',
                    body: 'body'
                },
                headers: 'response headers',
                statusCode: 'status code',
                statusMessage: 'status message',
                body: 'body'
            };
            stubRequest.callsArgWith(1, null, fakeResponse);
            sinon.stub(logger, 'getInstance');
            const debugStub = sinon.spy();
            logger.getInstance.returns({
                debug: debugStub
            });
            // call
            proxyhttpClient.request(VALID_OPTIONS, VALID_OPERATION, true, () => {
                // verify
                const expectedDebugContent = {
                    activity: VALID_OPERATION,
                    error: null,
                    "request-id": null,
                    request: {
                        method: 'method',
                        url: 'href',
                        headers: 'request headers',
                        body: 'body'
                    },
                    response: {
                        statusCode: 'status code',
                        statusMessage: 'status message',
                        headers: 'response headers'
                    },
                    body: 'body'
                };
                expect(logger.getInstance.called).equal(true);
                expect(debugStub.args[0][0]).deep.equal(expectedDebugContent);
                logger.getInstance.restore();
                done();
            });
        });
    });

});
