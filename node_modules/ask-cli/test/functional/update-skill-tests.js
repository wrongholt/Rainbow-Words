'use strict';

const expect = require('chai').expect;
const constants = require('./utils/constants');
const cliWrapper = require('./utils/cli-wrapper');
const message = require('./utils/messages');
const responseParser = require('./utils/response-parser');
const fs = require("fs");
const util = require('util');
const TIMEOUT = 80000;
const SKILL_FILE = './test/functional/fixture/custom-skill/skill.json';
const INVALID_FILE_PATH = './test/functional/fixture/custom-skill';
let skillId;

describe('# update skill tests', function () {
    this.timeout(TIMEOUT);
    before('set up', (done) => {
        this.timeout(TIMEOUT);
        cliWrapper.callCreateSkill(SKILL_FILE, constants.testData.PROFILE, (error, stdout, stderr) => {
            if (error) {
                console.log(`Failed to create skill`);
                done(error);
            } else {
                skillId = responseParser.getSkillID(stdout);
                expect(stdout.startsWith(message.CREATE_SKILL_SUBMITED)).equal(true);
                //check exit code should be 0
                done();
            }
        });
    });

    it('| update skill with valid skill id and file', (done) => {
        cliWrapper.callUpdateSkill(skillId, constants.testData.DEVELOPMENT_STAGE, SKILL_FILE, constants.testData.PROFILE, (error, stdout, stderr) => {
            if (error) {
                done(error);
            } else {
                expect(stdout.startsWith(message.UPDATE_SKILL_SUBMITED)).equal(true);
                done();
            }
        });
    });

    it('| update skill with invalid skill id', (done) => {
        cliWrapper.callUpdateSkill(constants.testData.INVALID_SKILL_ID, constants.testData.DEVELOPMENT_STAGE, SKILL_FILE, constants.testData.PROFILE, (error, stdout, stderr) => {
            expect(error);
            expect(stderr.startsWith(message.UPDATE_SKILL_ERROR_MSG) > -1).equal(true);
            done();
        });
    });

    it('| update skill with invalid file path', (done) => {
        cliWrapper.callUpdateSkill(constants.testData.VALID_SKILL_ID, constants.testData.DEVELOPMENT_STAGE, INVALID_FILE_PATH, constants.testData.PROFILE, (error, stdout, stderr) => {
            expect(error);
            expect(stderr.startsWith(message.INVALID_FILE_PATH_MSG) > -1).equal(true);
            done();
        });
    });

    it('| update skill with invalid profile', (done) => {
        cliWrapper.callUpdateSkill(constants.testData.VALID_SKILL_ID, constants.testData.DEVELOPMENT_STAGE, SKILL_FILE, constants.testData.INVALID_PROFILE, (error, stdout, stderr) => {
            expect(error);
            let errorMessage = util.format(message.INVALID_PROFILE_MSG, constants.INVALID_PROFILE);
            expect(stderr.startsWith(errorMessage) > -1).equal(true);
            done();
        });
    });

    after('tear down', (done) => {
        this.timeout(TIMEOUT);
        if (!skillId) {
            console.log('Create skill fail, skip delete skill operation');
            done();
        } else {
            cliWrapper.callDeleteSkill(skillId, constants.testData.PROFILE, (error, stdout, stderr) => {
                if (error) {
                    console.log(`Failed to delete ${skillId} when cleaning test data. Error: ${error}`);
                    done(error);
                } else {
                    expect(stdout).equal(message.DELETE_SKILL);
                    // exit code should be 0
                    done();
                }
            });
        }
    });
});