'use strict';

const expect = require('chai').expect;
const constants = require('./utils/constants');
const cliWrapper = require('./utils/cli-wrapper');
const message = require('./utils/messages');
const fs = require("fs");
const util = require('util');
const responseParser = require('./utils/response-parser');
const SKILL_FILE = './test/functional/fixture/custom-skill/skill.json';
let skillId;
const TIMEOUT = 80000;

describe('# get skill tests', function () {
    this.timeout(TIMEOUT);
    before('set up', (done) => {
        this.timeout(TIMEOUT);
        cliWrapper.callCreateSkill(SKILL_FILE, constants.testData.PROFILE, (error, stdout, stderr) => {
            if (error) {
                console.log(`Failed to create skill`);
                done(error);
            } else {
                skillId = responseParser.getSkillID(stdout);
                expect(stdout.startsWith(message.CREATE_SKILL_SUBMITED)).equal(true);
                //check exit code should be 0
                done();
            }
        });
    });

    it('| get skill with valid skill id', (done) => {
        cliWrapper.callGetSkill(skillId, constants.testData.DEVELOPMENT_STAGE, constants.testData.PROFILE, (error, stdout, stderr) => {
            if (error) {
                done(error);
            } else {
                fs.readFile(SKILL_FILE, 'utf8', function (err, data) {
                    if (err) throw err;
                    const expectedSkillDef = JSON.parse(data)
                    const actualSkillDef = JSON.parse(stdout);
                    expect(actualSkillDef).to.be.deep.equal(expectedSkillDef);
                    done();
                });
            }
        });
    });

    it('| get skill with invalid profile', (done) => {
        cliWrapper.callGetSkill(skillId, constants.testData.DEVELOPMENT_STAGE, constants.testData.INVALID_PROFILE, (error, stdout, stderr) => {
            expect(error);
            let errorMessage = util.format(message.INVALID_PROFILE_MSG, constants.INVALID_PROFILE);
            expect(stderr.startsWith(errorMessage) > -1).equal(true);
            done();
        });
    });

    it('| get skill with invalid stage', (done) => {
        cliWrapper.callGetSkill(skillId, constants.testData.INVALID_STAGE, constants.testData.PROFILE, (error, stdout, stderr) => {
            expect(error);
            expect(stderr.startsWith(message.NOT_FOUND_MSG) > -1).equal(true);
            done();
        });
    });

    it('| get skill with invalid skill id', (done) => {
        cliWrapper.callGetSkill(constants.testData.INVALID_SKILL_ID, constants.testData.DEVELOPMENT_STAGE, constants.testData.PROFILE, (error, stdout, stderr) => {
            expect(error);
            expect(stderr.startsWith(message.NOT_FOUND_MSG) > -1).equal(true);
            done();
        });
    });

    after('tear down', (done) => {
        this.timeout(TIMEOUT);
        if (!skillId) {
            console.log('Create skill fail, skip delete skill operation');
            done();
        } else {
            cliWrapper.callDeleteSkill(skillId, constants.testData.PROFILE, (error, stdout, stderr) => {
                if (error) {
                    console.log(`Failed to delete ${skillId} when cleaning test data. Error: ${error}`);
                    done(error);
                } else {
                    expect(stdout).equal(message.DELETE_SKILL);
                    // exit code should be 0
                    done();
                }
            });
        }
    });
});