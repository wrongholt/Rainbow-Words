'use strict';

const async = require('async');

const createLambda = require('../utils/lambda-operation/create-lambda');
const updateLambda = require('../utils/lambda-operation/update-lambda');
const profileHelper = require('../utils/profile-helper');
const installNodeModule = require('../utils/install-node-module');
const ifMatchUtil = require('../utils/if-match-utility');
const jsonUtility = require('../utils/json-utility');
const lambdaEndpointUtil = require('../utils/lambda-operation/lambda-endpoint-utility');
const retrieveLambda = require('../utils/lambda-operation/retrieve-lambda');
const CONSTANTS = require('../utils/constants');

module.exports = {
    deployLambda: deployLambda
};

function deployLambda(skillId, skillInfo, forceDeployment, profile, doDebug, callback) {
    if (!skillId) {
        console.error('No skill ID found. Please first create skill, then deploy lambda.');
        process.exit(1);
    }

    const awsProfile = profileHelper.getAWSProfile(profile);
    if (!awsProfile) {
        console.warn('[Warn]: Lambda deployment skipped because AWS credentials for profile [' +
            profile + '] are missing. CLI lambda functionalities can be' +
            " enabled by running `ask init` again to add 'aws_profile' to ASK cli_config");
        if (typeof callback === 'function' && callback) {
            callback();
        }
        return;
    }

    lambdaEndpointUtil.separateLambdaCreateUpdate(skillInfo.skillName, skillInfo.endpointsInfo, './', profile, (err, lambdaList) => {
        if (err) {
            console.error(err);
            process.exit(1);
        }

        const updateLambdaList = lambdaList.updateLambdaList;
        const createLambdaList = lambdaList.createLambdaList;
        if (updateLambdaList.length === 0 && createLambdaList.length === 0) {
            console.log('[Info]: No lambda functions need to be deployed.');
            callback();
            return;
        }

        // This is to check if the Lambda runtime is nodejs8.10 if it uses ask-sdk
        checkRuntimeForAskSdkUsage(updateLambdaList, awsProfile, (err, runtimeLessThenV8List) => {
            if (err) {
                console.error(err);
                process.exit(1);
            }
            if (runtimeLessThenV8List && runtimeLessThenV8List.length > 0) {
                console.warn('[Warn]: Please make sure the runtime of your Lambda function is "nodejs8.10" if you are using ask-sdk as a dependency.');
                console.warn('To change the runtime, you need to open the AWS Console, update the runtime to "nodejs8.10". Then use "ask deploy --force" to update the local Lambda to latest revisionId. Related Lambda function(s) are listed below: ');
                runtimeLessThenV8List.forEach(lambdaMetadata => {
                    console.warn(`  ${lambdaMetadata.arn}`);
                });
                process.exit(1);
            }

            installNodeModule.install(createLambdaList, updateLambdaList, process.cwd(), doDebug, () => {
                createLambda.createLambda(skillId, skillInfo.skillName, createLambdaList, awsProfile, (createdLambdaMetaDataList) => {
                    _fillUpInfoFromResourcesConfig(updateLambdaList, profile);
                    updateLambda.updateLambda(updateLambdaList, awsProfile, forceDeployment, (updatedLambdaMetaDataList) => {
                        // record new lambda revision ids
                        // create list need deep copied since the function will remove some properties from this step which will be used in downstream.
                        if (createLambdaList.length !== 0) {
                            ifMatchUtil.recordLambdaRevisionId(JSON.parse(JSON.stringify(createdLambdaMetaDataList)), profile);
                        }
                        if (updateLambdaList.length !== 0) {
                            ifMatchUtil.recordLambdaRevisionId(updatedLambdaMetaDataList, profile);
                        }
        
                        console.log('Lambda deployment finished.');
                        printLambdaDeployResults(createLambdaList,updateLambdaList);
                        if (typeof callback === 'function' && callback) {
                            callback(createdLambdaMetaDataList);
                        }
                    });
                });
            });
        });
    });
}

function checkRuntimeForAskSdkUsage(updateLambdaList, awsProfile, callback) {
    const runtimeLessThenV8List = [];
    async.each(updateLambdaList, (lambdaMetaData, retrieveCallback) => {
        if (!lambdaEndpointUtil.isLambdaUsingAskSdk(lambdaMetaData.sourceDir)) {
            return retrieveCallback();
        }

        retrieveLambda.retrieveLambdaRuntime(lambdaMetaData.arn, lambdaMetaData.awsRegion, awsProfile, (err, runtime) => {
            if (err) {
                return retrieveCallback(err);
            }
            if (runtime.startsWith('nodejs') && runtime !== 'nodejs8.10') {
                runtimeLessThenV8List.push(lambdaMetaData);
            }
            retrieveCallback();
        });
    }, (err) => {
        if (err) {
            return callback(err);
        }
        callback(null, runtimeLessThenV8List);
    });
}

function printLambdaDeployResults(createLambdaList, updateLambdaList){
    if (createLambdaList && createLambdaList.length > 0) {
        console.log('Lambda function(s) created:');
        createLambdaList.forEach(metaData => {
            console.log('  [Lambda ARN] ' + metaData.arn);
        });
    }
    if (updateLambdaList && updateLambdaList.length > 0) {
        console.log('Lambda function(s) updated:');
        updateLambdaList.forEach(metaData => {
            console.log('  [Lambda ARN] ' + metaData.arn);
        });
    }
}

function _fillUpInfoFromResourcesConfig(updateLambdaList, profile) {
    if (!updateLambdaList || updateLambdaList.length === 0) { 
        return;
    }
    const lambdaResourcePath = ['deploy_settings', profile, 'resources', 'lambda'];
    const lambdaListFromResources = jsonUtility.getProperty(CONSTANTS.FILE_PATH.PROJECT_CONFIG_PATH(process.cwd()), lambdaResourcePath);
    if (!lambdaListFromResources || lambdaListFromResources.length === 0) {
        return;
    }

    for (let updateLambdaMetaData of updateLambdaList) {
        for (let resourceLambdaMetaData of lambdaListFromResources) {
            if (updateLambdaMetaData.arn === lambdaEndpointUtil.removeLATESTFromArn(resourceLambdaMetaData.arn)) {
                for (let key of Object.keys(resourceLambdaMetaData)) {
                    if (!updateLambdaMetaData[key] || updateLambdaMetaData[key].length === 0) {
                        // need deep copy
                        updateLambdaMetaData[key] = JSON.parse(JSON.stringify(resourceLambdaMetaData[key]));
                    }
                }
                break;
            }
        }
    }
}
